\section{Discussion}
%Mondrian has the greatest F1-scores, however, slow runtime
From this study we observed that the Mondrian algorithm presents the best
classification performances.  However, we have also noticed that it is the
slowest classifier.

Concerning the high performance of the HoeffdingTree on
Figure~\ref{fig:f1-dataset_3}, we would like to remind that the RendomTree
dataset is a synthetic dataset generated using a tree structure. Therefore, we
expected the tree-based classifiers to show better performances.  However, we
noticed that from the two tree-based classifiers, only the HoeffdingTree
achieved such performance.  We suspect this difference to be caused by the lack
of split optimization in the Mondrian trees. Indeed, the Mondrian behavior is
more related to a nearest neighboor because it tries to split the space in
boxes of equal sizes rather than finding the best split. The good prediction is
then obtained by combining multiple trees in a forest.

%Link with litterature

%All F1-scores remains low
We observed that most of the f1-scores are low with the real datasets.

%Pk 1 capteur
In this study, we focus on using one sensor rather than all the sensors
available in the real datasets because it is more likely for a user to have one
sensor. It is cheaper to buy or build one sensor, and it is faster to setup.

%Pk 3 axes.

%Puissance, pk pas de différence significative (platform)
Section~\ref{sec:result-power} shows no power difference between classifier. This
observation is explainable by two factors. The plateform used is too powerful
and it was already working at minimal power. Indeed, to ensure no disturbance
by a background process, we run the classifier on an isolated cluster node with
eight cores. Therefore, the power difference on one core is not noticable.

Another reason is regarding the dataset size. Indeed, the slowest run is about
10 seconds with 50 Mondrian trees on \recofitdataset dataset.  Such short
execution does not leave the time for the CPU to switch P-states because it
barely warms a core.

% Mémoire contrainte, partir sur l'exploration : toute xp faite à mémoire constante, qu'est-ce qu'il se passe ac' + de mémoire.
In section~\ref{sec:result-memory}, we differenciate bounded memory and
constant space complexity because in the first case, a limited amount of memory
may impact the classifier performances. On the other hand, a constant space
complexity is a feature of a classifier and its performances are not expected
to change no  matter the amount of memory available. The classifier is simply
supposed to fail without the required amount of memory.


%Conclusion : Improve mondrian runtime





